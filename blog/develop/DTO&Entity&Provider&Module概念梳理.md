---
slug: module_provider_dto_entity
title: DTO&Entity&Provider&Module概念梳理
date: 2023-12-13
authors: kuizuo
tags: [server, cloud]
keywords: [develop, cloud]
---

`NestJS` 的代码组织方式是以**模块**为单位的。

`DTO`和`Entity` 是`NestJS`中非常关键的两个概念

## DTO(Data Transfer Object)

1. **定义：`DTO`** 全称是 Data Transfer Object，**数据传输对象**。它是一种用于数据传输的对象，通常用于在不同系统之间传输数据。DTO 通常只包含数据，不包含任何业务逻辑。
2. **作用：**
    - **一句话描述：**用于在不同系统之间传输数据。它可以帮助我们简化数据传输，提高数据传输的效率和可靠性。
    - **数据验证和转换：** DTO 可以用于验证传入的数据是否符合预期的格式和类型，并进行必要的数据转换。
    - **减少不必要的数据：** 可以选择性地排除一些不需要传输的字段，从而减少网络流量和提高性能。
    - **提高代码可维护性：** 使用 DTO 可以提高代码的可维护性，因为数据的传输逻辑被封装在对象中，易于理解和维护。
3. **为什么叫这个名字：** DTO 的名字来自于它的用途，即在系统内传输数据。它强调了它的目的是将数据从一个地方传输到另一个地方。
4. **解决什么问题：**
    1. 解决数据传输中的数据不一致问题。DTO 提供了一种机制来验证和转换传入的数据，确保它符合预期。例如，在前端应用程序中，我们可能需要将数据库中的日期字段格式化为特定格式，以便在 UI 中显示。这时，我们可以使用 DTO 来将数据库中的日期字段转换为特定格式。
    2. DTO 和 Entity 可以将业务逻辑与数据库操作分离，提高代码的可维护性。例如，如果我们有一个用户表，表中包含了用户名、密码、邮箱等字段。如果我们不使用 DTO 和 Entity，那么我们需要在 API 接口中编写业务逻辑，例如验证、校验等。这会使 API 接口更加复杂，难以维护和扩展。
    3. **数据传输和验证：**
        1. **问题：** 当客户端发送数据到服务器时，确保数据的格式和类型正确是关键的。没有明确定义的数据传输对象，可能导致数据格式错误或不一致。
        2. **解决方案：** 使用 DTO 定义客户端和服务器之间传输的数据结构，以及必要的验证规则。这确保了传输的数据符合预期，提高了数据的准确性。
    4. **减少不必要的数据传输：**
        1. **问题：** 有时客户端只需部分数据，但服务器传输了整个对象，导致网络带宽浪费。
        2. **解决方案：** 使用 DTO 可以选择性地包含或排除特定字段，只传输客户端所需的数据，减少了不必要的数据传输。
    5. **版本控制和向后兼容性：**
        1. **问题：** 随着应用程序的演进，数据结构可能会发生变化，可能需要向后兼容旧版本的客户端。
        2. **解决方案：** 使用 DTO 可以灵活地管理数据结构，对不同版本的客户端提供向后兼容的数据格式，而无需影响服务器的内部表示
    6. 开发者完全可以使用手动验证，只是复杂度上会高出很多。后期维护成本增大。官方只是给出了业界比较优秀的解决方案。

5. **如果不使用会怎么样：**
    1. 如果不使用 DTO，我们需要在不同系统之间传输完整的数据库表对象。这可能会导致数据传输中的数据不一致。
    2. 如果不使用 DTO，数据传输的逻辑可能分散在不同的地方，导致代码难以理解和维护。没有 DTO 的情况下，数据验证和转换可能会分散在多个地方，而不是集中在一个对象中。这可能导致代码重复、可读性差和难以维护。
    3. **如果不使用 DTO，那么在 API 中返回数据库的记录，将会导致数据库中所有字段都被返回，即使这些字段在 API 中没有使用。这将会使 API 更加复杂难懂，并降低性能。**

在控制器中使用 DTO，NestJS 会自动将传入的请求数据映射到 DTO 实例，并应用验证。

`DTO`通常在**控制器、服务、客户端和服务器之间通信** 被使用

1. 验证和转换操作只在控制器中被执行。
2. 验证和转换逻辑，在服务模块不会被触发，因为一定数据通过控制器层的验证，它们将被标记为有效和可信任的。在服务模块作用是数据的结构定义和传输，类似于`TypeScript`中的`Interface`，保持上下层数据的一致性和清晰的类型结构

## Entity(Entity Object)

1. **定义：Entity** 全称是 Entity Object，实体对象。它是一种用于表示数据库表的对象。Entity 通常包含数据库表中的所有字段，以及一些用于业务逻辑的属性和方法。
2. **作用：**
    - **一句话描述：**用于表示数据库表。它可以帮助我们简化数据库操作，提高数据库操作的效率和可靠性。
    - **持久化数据：** Entity 负责将应用程序中的数据映射到数据库中，实现数据的持久化。
    - **业务逻辑：** Entity 可以包含与数据相关的业务逻辑，例如计算属性、验证规则等。
    - **数据库交互：** Entity 可以通过 ORM（对象关系映射）与数据库进行交互，隐藏数据库操作的具体细节。
3. **为什么叫这个名字：** Entity 的名字来自于领域驱动设计（Domain-Driven Design）的概念，表示在领域模型中具有独立身份的对象。在数据库中，Entity 对应于表中的一行数据。
4. **解决什么问题：**解决数据库操作中的数据不一致问题。简化了数据库映射和交互的过程，使得与数据库的交互更加直观和方便。
    1. 例如，如果我们有一个用户表，表中包含了用户名、密码、邮箱等字段。如果我们不使用 Entity，那么我们需要编写大量的 SQL 语句来进行数据库操作。这会使数据库操作更加困难，而且不易于维护和扩展。如果我们使用 Entity，那么我们可以使用 TypeORM 等 ORM 框架来进行数据库操作。这样，我们只需要编写少量的代码就可以完成数据库操作。
    2. DTO 和 Entity 可以将业务逻辑与数据库操作分离，提高代码的可维护性。例如，如果我们有一个用户表，表中包含了用户名、密码、邮箱等字段。如果我们不使用 DTO 和 Entity，那么我们需要在 API 接口中编写业务逻辑，例如验证、校验等。这会使 API 接口更加复杂，难以维护和扩展。
    3. **晰的责任划分：**
        1. **问题：** 没有清晰的数据模型，业务逻辑和数据存储的职责可能会混合在一起，导致代码难以维护和理解。
        2. **解决方案：** 使用 Entity 将数据模型和数据库交互的逻辑封装在一起，使得代码的责任划分更加清晰，提高了代码的可维护性。
    4. **业务逻辑和验证规则：**
        1. **问题：** 数据的处理不仅涉及到存储，还可能包括与业务逻辑相关的处理，例如计算属性或复杂的验证规则。
        2. **解决方案：** 在 Entity 中可以包含与业务逻辑相关的方法和属性，确保在数据操作时应用正确的业务规则。
    5. **数据持久化和数据库映射：**
        1. **问题：** 将应用程序中的对象映射到数据库表中并执行 CRUD 操作时，需要一种结构化的方式来处理数据。
        2. **解决方案：** 使用 Entity 表示应用程序中的数据模型，它封装了与数据库相关的逻辑，简化了数据库映射和交互的过程。
    6. **映射数据库表**：Entity 可以映射数据库表，可以方便地进行数据库操作。
    7. **提供业务逻辑**：Entity 可以提供业务逻辑，例如验证、校验等。
    8. **提高代码的可维护性**：Entity 可以将业务逻辑与数据库操作分离，提高代码的可维护性。
5. **如果不使用会怎么样：**
    1. 如果不使用 Entity，我们需要自己管理数据库表的字段和属性。这可能会导致数据库操作中的数据不一致。
    2. 如果不使用 Entity，数据的持久化逻辑可能散布在应用程序的多个地方，而不是集中在一个对象中。这会使数据库操作变得混乱，难以管理。 Entity 提供了一种结构化的方式来处理数据的持久化和业务逻辑
    3. **如果不使用 Entity，那么在数据库中存储数据时，将会将所有字段都存储到数据库中，即使这些字段在业务逻辑中没有使用。这将会占用更多的数据库空间，并降低性能。**

## ValidationPipe

```tsx
new ValidationPipe({
    transform: true, // 启动自动转换
    forbidNonWhitelisted: true, // 仅允许白名单中提及的属性
    forbidUnknownValues: true, // 仅允许类中定义的属性，配出任何未知属性
    validationError: { target: false },
    groups: ['create'], // 仅应用于 create 组相关的验证规则
}),
```

在你的 DTO (**`CreatePostDto`**) 中只定义了 **`title`** 和 **`body`**，而在请求中传递了额外的字段（如 "shenyang" 和 "ntscshen"），并且同时设置了 **`forbidNonWhitelisted: true`** 和 **`forbidUnknownValues: true`**，那么验证应该失败，因为你配置了禁止未定义的字段。

预期的行为是正确的：传递了未定义在 DTO 中的字段，因此应该触发验证错误。验证错误的内容可能会包括类似 "shenyang" 和 "ntscshen" 这样的消息，指示这些字段是未定义的。

---

但事与愿违，在**`NestJS`**中被通过了，这两个多余字段被通过了 "shenyang" 和 "ntscshen"

---

当您设置了 forbidNonWhitelisted: true 和 forbidUnknownValues: true 时，您传递的参数中不应该包含非 CreatePostDto 类中定义的属性。

但是，validate() 方法将验证 data 对象中的所有属性，包括 shenyang 和 ntscshen 两个字段。由于 forbidNonWhitelisted: true 和 forbidUnknownValues: true 属性设置为 true，因此 validate() 方法将拒绝这些属性。

但是，validate() 方法将将这些属性添加到 errors 对象中，但不会抛出异常。

---

从结果看

```tsx
@Post()
    async createPost(
        @Body()
        data: CreatePostDto,
    ): Promise<PostEntity> {
        // 手动验证
        const errors: ValidationError[] = await validate(data, { groups: ['create'] });
        console.log('🚀 ~ file: post.controller.ts:56 ~ PostController ~ errors:', errors);

        if (errors.length > 0) {
            // 处理错误，例如返回错误响应
            console.error('---------99999---------', errors);
        }
        const newPost: PostEntity = {
            id: Math.max(...posts.map(({ id }) => id + 1)),
            ...data,
        };
        posts.push(newPost);
        console.log('🚀 ~ file: post.controller.ts:69 ~ PostController ~ newPost:', newPost);
        return newPost;
    }
```

```tsx
// 打印信息
---------99999--------- [
  ValidationError {
    target: {
      id: 6,
      title: '第七篇文章标题',
      body: '第七篇',
      shenyang: '1',
      ntscshen: 'haha'
    },
    value: undefined,
    property: undefined,
    children: [],
    constraints: {
      unknownValue: 'an unknown value was passed to the validate function'
    }
  }
]
```

使用 `validate` 确实命中了错误，但为什么 `new ValidationPipe` 没有命中

理论上展示的错误结果应该如下

```tsx
{
  "message": [
    "属性 shenyang 未在白名单中定义",
    "属性 ntscshen 未在白名单中定义"
  ],
  "error": "Bad Request",
  "statusCode": 400
}
```

这可能是由于 **`ValidationPipe`** 在某些情况下不会触发严格模式的原因，导致未定义的字段没有被正确地阻止。

**后期，将使用 全局中间件解决，或使用手动抛出异常的方式。**

## 提供者(provider)

提供过**类型提示**或**标示符**的方式使某个类或函数以依赖注入的方式在其他需要使用到它的地方进行实例化

在 NestJS 中，provider 可以是一个值、普通的类、工厂函数或者异步提供者

它可以被注入到模块、控制器、服务等地方

提供者(`provider`)是依赖注入的具体实现。

**什么是依赖注入**：一个对象**(依赖者)**依赖于另一个对象**(依赖项)**的功能，将依赖项的创建和管理责任委托给外部容器来管理的设计模式，而不是在依赖者内部进行硬编码。优点：松耦合、可维护

提供者的实现三步骤：

1. 依赖项：**`Injectable()` 装饰器：**
2. 依赖者：在类 `**constructor**` 中进行赋值，再使用
3. 外部容器：又称为 `IoC` 容器，它负责创建、配置和管理对象之间的依赖关系。在 `NestJS` 中这一层的容器由`Nest` 的 `@module` `providers` 接管

```tsx
@Module({
 controllers: [PostController],
 providers: [PostService] // IoC容器，注册提供者，被注册后才能被本模块的其他类注入
})
export class ContentModule {}
```

## 模块

**模块**在`NestJS`中组织应用程序的基本单元。将相关功能和组件组织起来。

NestJS中模块有以下几种

1. **根模块（`Root Module`）**：应用程序入口，负责初始化应用程序，并注册其他模块
2. **功能模块（`Feature Module`）**：用于实现特定功能，例如：创建一个模块来处理用户注册，在创建一个模块来处理用户登录
3. **共享模块（`Shared Module`）**：是指可以被多个 `NestJS` 应用程序使用的模块。主要解决：复用、避免重复、提高一致性等
4. **全局模块（`Global Module`）**：在整个应用程序中都能访问的提供者，不需要显式导入
5. **动态模块（`Dynamic Module`）**：允许你在运行时根据条件或配置信息动态地配置模块

---

运行时：开始执行请求和响应的过程。应用程序正在执行的实际时刻。例如：处理实际请求、执行业务逻辑等。

---

### 根模块

- 每个应用程序至少有一个模块，即根模块（Root Module）是应用程序的主模块。根模块是 Nest 用来构建应用程序图的起点。

    通常在一个名为`app.module.ts`的文件中定义，根模块通常命名为 `AppModule`。它必须使用 `@Module()` 装饰器进行装饰，并指定 `imports` 属性来注册其他模块。

    主要作用

    1. 初始化应用程序
    2. 注册其他模块
    3. 为应用程序提供基础设施：提供全局的服务、配置、功能

### 功能模块

- 功能模块（Feature Module）用于实现特定功能。功能模块可以帮助我们将相关的功能和组件组织在一起，提高代码的可读性、可维护性和可扩展性。保持代码有序并建立清晰的边界。

    例子：

  - **用户模块**：用于处理用户注册、登录、修改密码等功能。
  - **商品模块**：用于处理商品列表、商品详情、购物车等功能。
  - **订单模块**：用于处理订单创建、支付、发货等功能。

### 共享模块

`NestJS` 中的共享模块是指可以被多个 `NestJS` 应用程序使用的模块。

在 `Nest` 中，默认情况下每个模块只会被实例化一次。当您创建一个模块并将其注入到其他模块时，NestJS 会确保只有一个该模块的实例被创建和使用。由于模块是单例的，因此当您在一个模块中注入另一个模块时，它们实际上共享同一个模块的实例。这意味着如果您在一个模块中对某个提供程序进行了更改或设置了状态，那么在其他使用同一模块的模块中也会看到这些更改和状态。

这意味着，对于任何给定的模块，无论它被导入多少次，都只会创建一个实例。

假设我想在 `DogsModule` 模块中调用 `CatsModule` 模块的 `CatsService` 提供者。

为此，我们首先需要导出 `CatsService` 提供者，将其添加到模块的导出数组中，如下所示：

```tsx
@Moduel({
 providers: [CatsService],
 exports: [CatsService]
})
export class CatsModule {}
```

然后在 `DogsModule` 模块中使用 `imports` 导入，这样就可以在 `DogsModule` 的控制器、提供者中注入`CatsService` 如下所示：

```tsx
@Module({
 imports: [CatsModule]
 controllers: [DogController]
 providers: [...]
})
export class DogsModule {}
```

```tsx
@Controller()
export class DogController {
 // 通过构造器，声明对CatsService的依赖
 constructor (private catsService: CatsService) {}
 ...
}
```

### 全局模块

为什么会出现全局模块：在大多数情况下，使用**功能模块**和**共享模块**就可以满足绝大多数的应用程序需求。但是，对于一些应用程序，我们可能需要在整个应用程序范围内使用同一组提供者程序。

例如：数据库连接模块、日志记录模块、配置服务模块 等等

可以使用 @Global() 装饰器将模块设为全局。全局模块应该仅在一个地方注册，通常是根模块或核心模块。

假设我现在需要一个数据库连接模块，此时我需要创建一个名为 `GlobalDbModule` 的全局模块，负责创建和管理数据库连接，如下所示：

第一步：创建一个全局模块

```tsx
@Global()
@Module({
 providers: [GlobalDbService],
 exports: [GlobalDbService]
})
export class GlobalDbModule {}
```

第二步：导入根模块，通过根模块注册

```tsx
@Module({
 imports: [GlobalDbModule],
})
export class AppModule {}
```

第三步：使用。此时`GlobalDbModule` 将无处不在，不需要在其模块中导入 `GlobalDbModule` 模块

```tsx
@Controller()
export class loginController {
 constructor(private globalDbService:GlobalDbModule) {}
 ...
}
```

### 动态模块（Dynamic）

考虑这样一种情况，我们有一个通用的模块，需要在不同的用例中表现出不同的行为。

例如，为开发人员使用开发数据库，为测试/预演环境使用预演数据库等。

通过将配置参数的管理委托给配置模块，应用程序源代码保持独立于配置参数。**通过将配置参数的管理委托给配置模块，应用程序源代码可以与配置参数保持独立。这意味着应用程序源代码不需要直接引用配置参数，而是通过配置模块来访问配置参数。**

1. 配置模块负责读取和管理配置参数，并在运行时将它们提供给应用程序使用。这样，应用程序的源代码就不需要直接处理配置参数，而是依赖于配置模块来获取所需的配置信息。

配置模块本身，因为它是通用的，需要被使用它的模块进行定制。这就是动态模块发挥作用的地方。

动态模块提供了一种API，允许将一个模块导入到另一个模块中，并在导入时定制该模块的属性和行为，而不是使用我们到目前为止所见到的静态绑定。

静态导入

```tsx
@Module({
  imports: [ConfigModule]
})
export class AppModule {}
```

动态导入

```tsx
@Module({
  imports: [ConfigModule.register({ folder: './config' })],
})
export class AppModule {}
```

1. `ConfigModule` 是一个普通的类，所以我们可以推断它必须有一个名为 `register()` 的静态方法。
2. 创建的方法可以是任意的名称，按照惯例，我们应该将其命名为 `forRoot()` 或 `register()`。
3. 我们可以推断 `register()` 方法必须返回类似于模块的东西，因为它的返回值出现在我们熟悉的导入列表中
4. 实际上，我们的 `register()` 方法将返回一个 `DynamicModule`。动态模块只是在运行时创建的模块，具有与静态模块完全相同的属性，再加上一个额外的称为 `module` 的属性。这是唯一和静态模块不一样的地方。module 属性用作模块的名称，与模块的类名相同。

---

社区准则（NestJS 社区的最佳实践）

`forRoot`、`register` 和 `forFeature` 是 NestJS 中用于创建动态模块的三种方法。

- `forRoot` 方法用于将模块作为**`< 全局模块 >`**注册。
  - **`forRoot`**通常用于根模块（AppModule）中，以提供全局配置。例如数据库连接或日志记录。
- `register` 方法用于将模块作为`**< 特定模块 >**`的子模块注册。
  - **`register`**通常用于动态模块中，允许传递异步配置或基于不同环境的配置。这对于需要根据运行时信息动态配置模块的情况非常有用。
- `forFeature` 方法用于将模块作为**`< 特定功能 >`**的子模块注册。
  - **`forFeature`**方法主要用于功能模块（feature modules）中，用来定义模块所特有的提供者（providers）和控制器（controllers）。通过**`forFeature`**，你可以确保功能模块的特定服务只在该模块内部可用，增强了模块的封装性。
  - **`forFeature`**用于定义模块特有的提供者（providers）和控制器（controllers），它确保这些服务只在该模块内部可用。

我对动态模块理解和约定俗称的定义理解如下：

动态模块的核心目的，是根据传递的不同内容返回不同的`Module`，而定义在对应模块上的静态属性

`forRoot` 通常用于设置**跨整个应用程序共享**的配置或服务。例如：数据库连接就是一个典型用例。这个方法通常用于，那些只需要在应用程序启动时配置一次的全局资源。

1. 配置数据库连接池（根据不同配置动态创建数据库连接）
2. 全局日志配置（所有模块使用统一的日志配置）
3. 消息队列服务集成（配置队列连接、重连策略、交换机类型等）

`register` 翻译过来是注册、登记的意思。主要用于更**复杂**或**异步**的配置场景。例如

1. 配置服务（接口返回）
2. 动态邮件服务（根据不同的用户选择不同的模板）
3. 集成第三方服务（通过接口返回密钥或配置）

`forFeature` 功能，确保这些服务只服务于当前模块。例如

1. 订单模块：用于封装与定单模块相关的服务和控制器。确保这些服务只在订单模块内部可用。
2. 健康模块：`**forFeature`** 用来定义一个健康模块，该模块内部包含检查各种服务状态的控制器和服务，而这些功能只对健康检查模块可见
3. 用户认证模块：`**forFeature`** 创建一个专门处理用户认证和授权模块，这个模块包含了与用户认证相关的逻辑和服务。且只对用户认证模块可见

其实这个字段( forRoot, register, forFeature )可以改成任何信息，怎么去写只是将商业开发中常见的功能进行大类的划分，让其他开发者看到名称就能了解当前的动态模块，服务的那种类型的功能

比如：`forRoot` 通常用于全局配置， `register` 用于动态配置， `forFeature` 用于特定模块的功能。这些约定俗成的名称，可以使其他开发者更快速的阅读、理解、维护当前模块的作用。

这些名词并不是强制的，可以根据自己/团队的实际情况进行命名调整，以更好的适应特定的项目结构和团队文化。
